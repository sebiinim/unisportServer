3. 엔티티별 세부 기능
    1) Lesson : 강사 인증된 사용자가 생성할 수 있다. 등록/조회/수정/삭제의 CRUD 구성. 수업의 핵심 정보를 담는다. 유저, 관심등록, 리뷰 등 모든 테이블과 관련이 있는 핵심 객체. 
    2) LessonSchedule : Lesson을 이용해 날짜, 시간 등을 추가하여 실제 수업을 만든다. 사용자는 이 객체에 예약을 걸고 출석을 인증받는다.
    3) Reservation : 출석 엔티티까지 자동으로 생성한다. 
    4) Review : 레슨을 수강한 사용자가 작성한다. 최신순, 평점순 등 정렬 기준을 세부화한 API로 개발 및 사용자 편의성을 높였다. 
    5) User : 회원가입 시 받은 password는 BCryptPasswordEncoder로 해시화한 값을 저장한다. 로그인 시 입력한 비밀번호의 해시값과 저장된 값을 비교하는 방식으로 보안 안정성을 높였다.




4-1. 차별화 포인트(백엔드)
예약과 출석 데이터를 연동하여 관리를 일부 자동화하고 데이터 정합성을 높였다.
정원 체크, 엔티티 존재 체크 등을 꼼꼼히 하여 실제 서비스처럼 예외 처리에 집중하였다.
확장성 있는 구조를 유지하기 위해 Controller, Dto, Service, Entity, Repository 구조를 채택하였다. 
Render + GCP로 배포 자동화 파이프라인을 구성하였다.
도메인 경로를 REST 규칙을 지켜서 만들었다.




5. 개발 프로세스

5-1. 기획
대학생 중심의 스포츠 레슨 커뮤니티 앱을 개발하기로 기획하였다.
기존 앱들의 문제점(유휴 스포츠 자원의 낭비)를 극복하는 것이 목표이다.
로그인/가입, 수업 개설, 예약, 출석체크, 리뷰 등으로 이어지는 이용자 시나리오를 정의했다.
이에 맞추어 MVP 개발부터 시작했고 스크럼 방식으로 주 2-3회 회의를 진행했다. 

5-2. 설계
Lesson, LessonLike, LessonSchedule, User, Reservation, Attendance, Review 등 스키마를 정의했다.

5-3. 구현
SpringBoot를 사용하여 RESTful한 API를 개발하기로 했다.

5-4. 테스트
백엔드 개발 시 Swagger를 통한 경계 조건 테스트를 꾸준히 진행하였다.
예외 시 RuntimeException 등을 발생시켜 프론트엔드 측에서 상황을 정확히 인지하는 데 도움을 주었다. 

5-5. 배포 및 운영
백엔드 배포(서버)는 Render를 이용한다.
github push 시 최신 개발 커밋이 테스트서버에 자동 배포된다.
main에 merge시 본 서버가 최신 상태로 배포된다. 

데이터베이스는 GCP의 Cloud SQL과 Cloud Bucket을 이용하였다. 
대부분의 MySQL DB는 Cloud SQL이고 레슨 사진을 저장하기 위해 Bucket을 이용한다. 

프론트엔드는 ...

5-6. 향후 계획
뭐가있을까요
구독 실제로 구현, 결제 시스템 만들기


5-7. 시행착오&배운 점(백엔드)

Render와 GCP(Google Cloud Platform)의 Cloud SQL 인스턴스를 연결하는 과정에서 0.0.0.0/0 으로 포트를 열어 두었다가 랜섬웨어 공격을 받아 DB가 삭제되는 상황이 있었다. GCP proxy를 이용해서 로컬에서 접속하였고 Render로 배포 시에도 proxy 프로세스를 실행하여 안전하게 연결하도록 하였다. 

서버 및 Docker의 캐시가 계속하여 커지므로 주기적으로 초기화해줘야 한다는 것을 배웠다. 

엔티티, Dto, 레포지토리의 관계성을 학습하고 request와 response를 구분할 필요성을 느꼈다. 

- 예외 처리
레슨 예약 시 현재 예약 인원이 정원보다 많은 경우 예외처리
예약 시 출석 엔티티도 자동으로 생성하여 출석을 용이하게 한다. 

JPA 메서드 네이밍을 이용하여 쿼리를 자동 생성하였다. 

관심 레슨 -> ManyToOne -> 레슨, 출석 -> ManyToOne -> 레슨 스케줄 등 One과 Many를 적절히 이용해 엔티티끼리 매핑하였다. 

깃허브 브랜치 사용 및 테스트서버의 필요성을 간절하게 느꼈다. 

